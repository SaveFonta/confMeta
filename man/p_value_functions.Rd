% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pfun_edgington.R, R/pfun_fisher.R,
%   R/pfun_hmean.R, R/pfun_ktrials.R, R/pfun_pearson.R, R/pfun_tippett.R
\name{p_edgington}
\alias{p_edgington}
\alias{p_fisher}
\alias{p_hmean}
\alias{p_ktrials}
\alias{p_pearson}
\alias{p_tippett}
\title{\emph{p}-value functions}
\usage{
p_edgington(
  estimates,
  SEs,
  mu = 0,
  heterogeneity = "none",
  phi = NULL,
  tau2 = NULL,
  alternative = "two.sided",
  check_inputs = TRUE,
  approx = TRUE
)

p_fisher(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE
)

p_hmean(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "none",
  check_inputs = TRUE,
  w = rep(1, length(estimates)),
  distr = "chisq"
)

p_ktrials(
  estimates,
  SEs,
  mu,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "none",
  check_inputs = TRUE
)

p_pearson(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = c("none", "additive", "multiplicative"),
  check_inputs = TRUE
)

p_tippett(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE
)
}
\arguments{
\item{estimates}{Numeric vector of effect estimates.}

\item{SEs}{Numeric vector containing the standard errors of the effect
estimates.}

\item{mu}{A numeric vector containing null hypothesis value(s).}

\item{heterogeneity}{One of \code{c("none", "additive", "multiplicative")}. If \code{heterogeneity = "none"} p-values are returned for the
passed \code{se} without any adaption. If \code{heterogeneity = "additive"}, the standard errors \code{se} are reassigned the value of \code{sqrt(se^2 + tau2)} before
computation of the p-values. If \code{heterogeneity = "multiplicative"}, the standard errors \code{se} are multiplied with the value of \code{phi} before
computation of the p-values. Defaults to \code{"none"}.}

\item{phi}{A numeric vector of length 1. Must be finite and larger than 0. The square root of the argument is used to scale the standard errors.}

\item{tau2}{A numeric vector of length 1.}

\item{alternative}{Either \code{"greater"}, \code{"less"}, \code{"two.sided"}, or \code{"none"} (default).
Specifies the alternative to be considered in the computation of the p-value.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}

\item{approx}{Must be either TRUE (default) or FALSE. If TRUE, the p-value
is computed using the normal approximation of the Irwin-Hall distribution
whenever \code{length(estimates) >= 12}. This avoids issues that
can lead to overflow of the double precision floating point numbers R
uses for numeric vectors.}

\item{w}{Numeric vector of weights.}

\item{distr}{The distribution to use for the calculation of the p-value. Currently, the options are
\code{"f"} (F-distribution) and \code{"chisq"} (Chi-squared distribution). Defaults to \code{"chisq"}.}
}
\value{
The corresponding p-values given mu under the null-hypothesis.
}
\description{
\emph{p}-value functions
}
\details{
All functions are vectorized over the \code{mu} argument.
}
\examples{
    # Simulating estimates and standard errors
    n <- 15
    estimates <- rnorm(n)
    SEs <- rgamma(n, 5, 5)

    # Calculate the between-study variance tau2
    tau2 <- estimate_tau2(estimates = estimates, SEs = SEs)
    phi <- estimate_phi(estimates = estimates, SEs = SEs)

    # Set up a vector of means under the null hypothesis
    mu <- seq(
      min(estimates) - 0.5 * max(SEs),
      max(estimates) + 0.5 * max(SEs),
      length.out = 1e5
    )

    # Using Edgington's method to calculate the combined p-value
    # for each of the means with additive adjustement for SEs
    p_edgington(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "additive",
        tau2 = tau2
    )
    # Using Fisher's method to calculate the combined \emph{p}-value
    # for each of the means with multiplicative adjustement for SEs
    p_fisher(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )

    # Using the harmonic mean method to calculate the combined p-value
    # for each of the means with additive adjustment for SEs.
    p_hmean(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "additive",
        tau2 = tau2,
        distr = "chisq"
    )

    # Using the k-trials method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_ktrials(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
    # Using Pearson's method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_pearson(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
    # Using Tippett's method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_tippett(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
}
