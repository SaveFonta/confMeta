% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pfun_edgington.R, R/pfun_fisher.R,
%   R/pfun_hmean.R, R/pfun_ktrials.R, R/pfun_pearson.R, R/pfun_tippett.R,
%   R/pfun_stouffer.R
\name{p_edgington}
\alias{p_edgington}
\alias{p_fisher}
\alias{p_hmean}
\alias{p_ktrials}
\alias{p_pearson}
\alias{p_tippett}
\alias{p_stouffer}
\title{\emph{p}-value functions}
\usage{
p_edgington(
  estimates,
  SEs,
  mu = 0,
  heterogeneity = "none",
  phi = NULL,
  tau2 = NULL,
  alternative = "two.sided",
  check_inputs = TRUE,
  approx = TRUE,
  input_p = "greater"
)

p_fisher(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE,
  input_p = "greater"
)

p_hmean(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "none",
  check_inputs = TRUE,
  w = rep(1, length(estimates)),
  distr = "chisq"
)

p_ktrials(
  estimates,
  SEs,
  mu,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "none",
  check_inputs = TRUE,
  input_p = "greater"
)

p_pearson(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE,
  input_p = "greater"
)

p_tippett(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE,
  input_p = "greater"
)

p_stouffer(
  estimates,
  SEs,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "two.sided",
  check_inputs = TRUE,
  w = NULL
)
}
\arguments{
\item{estimates}{Numeric vector of effect estimates.}

\item{SEs}{Numeric vector containing the standard errors of the effect
estimates.}

\item{mu}{A numeric vector containing null hypothesis value(s).}

\item{heterogeneity}{One of \code{c("none", "additive", "multiplicative")}. If \code{heterogeneity = "none"} p-values are returned for the
passed \code{se} without any adaption. If \code{heterogeneity = "additive"}, the standard errors \code{se} are reassigned the value of \code{sqrt(se^2 + tau2)} before
computation of the p-values. If \code{heterogeneity = "multiplicative"}, the standard errors \code{se} are multiplied with the value of \code{phi} before
computation of the p-values. Defaults to \code{"none"}.}

\item{phi}{A numeric vector of length 1. Must be finite and larger than 0. The square root of the argument is used to scale the standard errors.}

\item{tau2}{A numeric vector of length 1.}

\item{alternative}{Either \code{"greater"}, \code{"less"}, \code{"two.sided"}, or \code{"none"} (default).
Specifies the alternative to be considered in the computation of the p-value.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}

\item{approx}{Must be either TRUE (default) or FALSE. If TRUE, the p-value is
computed using the normal approximation of the Irwin-Hall distribution
whenever \code{length(estimates) >= 12}. This avoids issues that can lead
to overflow of the double precision floating point numbers R uses for
numeric vectors.}

\item{input_p}{Either \code{"two.sided"}, \code{"less"}, or \code{"greater"}
(default). Specifies whether two-sided or one-sided p-values are used as
inputs for a p-value combination method.}

\item{w}{Numeric vector of weights.}

\item{distr}{The distribution to use for the calculation of the p-value. Currently, the options are
\code{"f"} (F-distribution) and \code{"chisq"} (Chi-squared distribution). Defaults to \code{"chisq"}.}
}
\value{
The corresponding p-values given \eqn{mu} under the null-hypothesis.
}
\description{
\if{html}{\out{<div class="sourceCode">}}\preformatted{These functions combine individual effect estimates and the corresponding
standard errors into a single \\emph\{p\}-value. Under the hood, all of the
functions transform the estimates and standard errors into \\emph\{z\}, and
subsequently into \\emph\{p\}-values. The resulting \\emph\{p\}-values are
combined into the chosen statistic and an appropriate distribution is
used to derive the combined \\emph\{p\}-value.

All of the \\emph\{p\}-value functions are vectorized over the \code{mu}
argument.
}\if{html}{\out{</div>}}
}
\note{
Add references to p-value statistics.
}
\examples{
    # Simulating estimates and standard errors
    n <- 15
    estimates <- rnorm(n)
    SEs <- rgamma(n, 5, 5)

    # Calculate the between-study variance tau2
    tau2 <- estimate_tau2(estimates = estimates, SEs = SEs)
    phi <- estimate_phi(estimates = estimates, SEs = SEs)

    # Set up a vector of means under the null hypothesis
    mu <- seq(
      min(estimates) - 0.5 * max(SEs),
      max(estimates) + 0.5 * max(SEs),
      length.out = 1e5
    )

    # Using Edgington's method to calculate the combined p-value
    # for each of the means with additive adjustement for SEs
    p_edgington(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "additive",
        tau2 = tau2
    )
    # Using Fisher's method to calculate the combined \emph{p}-value
    # for each of the means with multiplicative adjustement for SEs
    p_fisher(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )

    # Using the harmonic mean method to calculate the combined p-value
    # for each of the means with additive adjustment for SEs.
    p_hmean(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "additive",
        tau2 = tau2,
        distr = "chisq"
    )

    # Using the k-trials method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_ktrials(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
    # Using Pearson's method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_pearson(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
    # Using Tippett's method to calculate the combined p-value
    # for each of the means with multiplicative adjustement for SEs
    p_tippett(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
    # Using weighted Stouffer's method to calculate the combined p-value for
    # each of the means with multiplicative adjustement for SEs
    p_stouffer(
        estimates = estimates,
        SEs = SEs,
        mu = mu,
        heterogeneity = "multiplicative",
        phi = phi
    )
}
